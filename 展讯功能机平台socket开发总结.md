# 展讯功能机平台socket开发总结



### 1.task线程之间关系

- app task是主线程,影响UI. 操作socket,接收发送都需要创建一个子线程来处理
- 利用发送消息在各个task中通信
-  全局变量data访问

### 2.socket安全接收机制

- 设置socket为非阻塞
- 异步接收socket数据,判断left_len>0,说明tcp缓冲区还有未取完的数据,给接收数据的task发送read消息,继续循环接收,直至left_len为0,接收完毕

### 3.粘包,大数据处理

- 粘包,对端快速发送多条命令时,设备端这边tcp缓冲区可能是一次性接收完成的. 只要总长度小于接收buffer,可一次性接收下来,然后根据自定义协议解析即可
- 大数据,默认设置接收buffer为4KB,一般CMD不会超过,当对方一次发送数据过大时,比如图片,音频,视频等,超过自身接收buffer,要分多次才能接收完成,判断left_len>0,说明是大数据,循环接收保存本地文件中,直至left_len=0.完成一次接收. 然后处理保存的数据即可
- 可能存在其他异常,需实际测试环境暴露



### 4.第三条存在问题

- 经过实测,6531e的mtu是1400byte,实际去掉tcp的包头,应用层能一次接收的实际数据为1352byte

  故一次发送超过1352byte的数据,系统会自动分包发送(最大不能超过mtu).

  分下述两种情况

  1.接收buffer大于mtu时,比如一次发送1500byte时,socket这边会先接收到1352,此时left_len也为0. 然后再收到一次read消息,接收余下的148byte

  所以left_len的作用只能告诉还有数据没接收完,不能判断一次包有没有发完.即使一次发完了,mtu也会分包

  2.接收buffer小于mtu. 这时处理起来比较麻烦,需要判断条件更多  .所以必须采用第一种方式,一般mtu不会超过1500byte,接收buffer定义为大于1500即可

- tcp传输数据就像水管流水一样,无法在tcp层来判断粘包 分包问题. 必须应用层根据自定义的协议格式来判断

### 5.应用层根据自定协议分包处理

- 以

  ```
  0015CS*1234567890*LK
  ```

   为例,4个byte长度,设置一个变量标识是初始包还是后续没发完的包.

  初始包时取前4个byte计算长度,

  1.如果长度正好等于此次接收到的包长,说明一次完整包接收到,进行解析即可

  2.如果长度大于此次接收的数据长度,说明一次没发完,需要将变量标识改为未发完的,下次接收到的数据直接拼接到后面,根据总长度判断完成.

  3.如果此次接收数据大于定义包长,说明此次数据是无效的,可以直接丢弃,或者关闭连接